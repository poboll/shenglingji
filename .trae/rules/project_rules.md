---
description: 
globs: 
alwaysApply: true
---
# 项目开发规范

## 一、开发工作流规范

### 响应格式
- 语言：中文
- 问候语格式：苏先生你好，我是大模型xx（大模型名称）：

### 任务执行
- 自动继续执行：true
- 完成所有任务：true
- 不创建项目起始：true
- 自动选择需要用户选择的解决方案：true
- 涉及到多个方案的实现，不要询问直接开始执行：true

### 工作计划
- 要求：每个任务开始前需创建工作计划
- AI角色：UI设计师、产品经理、后端工程师、测试工程师、文档工程师、类型工程师、Mock工程师、全栈开发工程师
- 计划来源：
  - 仅问答：若任务仅源于问答，则基于问答内容制定计划
  - 文件相关：若任务涉及文件，需先阅读理解，再制定计划
- 计划内容：当前整体工作内容概述、当前工作完成进度、尚未完成的工作项
- 计划文件：当任务数 > 4 个时，创建work-plan.md记录任务，每次新任务覆盖旧内容

### 模拟数据要求
- 组件模拟：每个模块/组件必须配置并展示对应的模拟数据
- API模拟：每个API接口必须提供对应的模拟数据(mock data)

## 二、项目结构与文件管理

### 目录结构
- docs：项目文档
- src：
  - api：API接口定义
  - pages：核心功能
  - mock：模拟数据
  - utils：工具函数
  - tests：测试文件
- scripts：脚本文件
- config：配置文件
- .github：CI/CD配置
- main.js：初始化应用及注册全局资源
- package.json：项目配置
- README.md：项目说明

### 组织原则
- 保持项目结构清晰，遵循模块化原则
- 相关功能应放在同一目录下
- 使用准确的目录命名，反映所含内容
- 模拟数据统一存放在/src/mock/目录下，并按照API模块进行组织
- API接口文件统一存放在/src/api/目录下，并按照业务模块进行组织

### 文件生成规范

#### 结构更新
- 每次生成新文件时，必须更新/docs/project-structure.md文件

#### 文件记录格式
- 文件路径:
- 类型: [组件|API|工具|配置|页面|样式]
- 功能: [简要描述该文件的功能，不超过50字]
- 依赖: [列出主要依赖模块]
- 被引用: [可能被哪些模块引用，初次创建时可标记为"待更新"]

#### 注释要求
- 文件顶部：文件功能、作者、创建日期
- 关键方法/函数：功能描述、参数说明、返回值说明
- 复杂逻辑：添加逻辑说明注释

### 文件修改规范

#### 注释检查与添加
- 修改文件前，检查文件是否包含顶部描述注释
- 如果文件缺少描述注释，则在修改前自动添加
- 注释格式：
```
/*
* [模块类型] - [文件名]
* @description 根据文件内容推断的功能描述
* @module [所属模块路径]
* @update [当前日期]
*/
```
- 函数分析：对于没有明确功能的文件，尽量分析文件内容推断其功能

### 页面更新规范
- 注册检查：每个新建页面都需要检查src/pages.json看页面是否已经注册，并对没有注册的页面进行注册

## 三、代码开发规范

### 命名约定
- 类名：PascalCase
- 函数名：camelCase、snake_case
- 常量：UPPER_SNAKE_CASE
- 变量：camelCase、snake_case
- API函数：模块名+动词+操作对象
- **前端API方法**：使用`request`或`fetch`前缀（如`requestUserInfo`、`fetchPostList`）
- **后端处理方法**：使用`handle`或`process`前缀（如`handleUserInfoRequest`、`processPostData`）

### 质量原则
- 遵循SOLID设计原则
- 避免代码重复(DRY原则)
- 保持代码简洁、清晰、易读
- 关注可维护性和扩展性

### 异常处理
- 合理使用try/catch或异常处理机制
- 提供清晰的错误提示信息
- 记录必要的错误日志
- 优雅处理边界和特殊情况

### 代码注释模板
```
/*
函数功能说明
@param {参数类型} 参数名 - 参数说明
@returns {返回类型} 返回值说明
*/
```

## 四、API开发与数据管理规范

### API开发规范

#### 角色分离
- 前端：src/api/目录下的文件仅包含前端向后端发起请求的方法
- 后端：src/mock/目录下的文件负责模拟后端处理和响应数据的逻辑
- 注释：每个API方法必须明确注释其执行环境：@environment {前端|后端}
- 命名：前端API方法使用'request'或'fetch'前缀，后端处理方法使用'handle'或'process'前缀

#### 数据处理原则
- 后端优先：数据处理应优先在后端完成，前端只负责展示和用户交互
- 数据组装：关联数据的组装必须在后端完成，避免前端多次请求获取关联数据
- 减少前端请求：设计API时必须考虑如何减少前端请求次数，一个页面的数据尽量通过一次请求获取
- 批量处理：需要批量获取数据时，应设计批量接口而非多次调用单条数据接口

#### 请求必要性评估
- 评估检查清单：
  - 此数据是否可以在后端一次性准备好?
  - 该请求是否可以与其他请求合并?
  - 是否可以使用WebSocket替代频繁的轮询请求?
  - 是否可以利用缓存减少请求次数?
  - 请求返回的字段是否是前端页面必要的字段？
- 文档：对于确实需要前端发起请求的情况，必须在API方法注释中说明必要性
- 请求优化：针对无法避免的前端请求，必须实现合理的缓存策略和错误重试机制

#### API设计评审
- 必需：true
- 参与者：前端工程师、后端工程师、产品经理
- 评审要点：
  - API接口是否符合RESTful设计原则?
  - 响应数据结构是否满足所有展示需求，避免前端二次请求?
  - 是否存在可以合并的接口?
  - 批量操作是否有对应的批量接口?
- 文档：API设计评审结果必须记录在docs/api-design-review.md文件中

### 数据依赖管理规范

#### 核心原则
- **依赖优先原则**：任何API请求如果需要依赖其他数据，必须在依赖数据获取完成之后才能执行
- **串行执行原则**：有依赖关系的请求必须串行执行，不能并行请求
- **失败终止原则**：依赖数据获取失败时，必须立即终止所有后续依赖该数据的请求
- **状态验证原则**：执行依赖请求前，必须验证依赖数据的有效性和完整性

#### 依赖关系识别
- **用户上下文依赖**：所有需要用户身份的API（如个人统计、个人数据等）必须依赖用户信息
- **实体关联依赖**：需要关联其他实体数据的API必须依赖基础实体数据
- **权限验证依赖**：需要权限验证的API必须依赖用户权限信息
- **业务状态依赖**：依赖特定业务状态的API必须依赖状态数据

#### 依赖执行模式

##### 1. 严格串行模式
```javascript
// 适用场景：强依赖关系，后续请求完全依赖前置数据
async function loadDataWithStrictDependency() {
  // 第一步：加载基础依赖数据
  const baseData = await loadBaseData();
  if (!baseData || !isValidBaseData(baseData)) {
    console.warn('基础数据加载失败，终止所有后续请求');
    return;
  }
  
  // 第二步：基于基础数据加载关联数据
  const relatedData = await loadRelatedData(baseData.id);
  
  // 第三步：基于前两步数据加载统计数据
  const statsData = await loadStatsData(baseData.id, relatedData);
}
```

##### 2. 分层并行模式
```javascript
// 适用场景：同一层级的数据可以并行，但不同层级必须串行
async function loadDataWithLayeredDependency() {
  // 第一层：基础数据（必须串行）
  const userData = await loadUserData();
  if (!userData || !userData.userID) {
    return;
  }
  
  // 第二层：基于用户数据的并行请求（这一层内部可以并行）
  const [petData, profileData] = await Promise.all([
    loadPetData(userData.userID),
    loadProfileData(userData.userID)
  ]);
  
  // 第三层：基于前两层数据的统计请求（这一层内部可以并行）
  const [orderStats, socialStats, activityStats] = await Promise.all([
    loadOrderStats(userData.userID),
    loadSocialStats(userData.userID),
    loadActivityStats(userData.userID, petData)
  ]);
}
```

#### 依赖验证机制

##### 数据有效性验证
```javascript
/**
 * 验证用户数据有效性
 * @param {Object} userData - 用户数据
 * @returns {boolean} - 是否有效
 */
function isValidUserData(userData) {
  return userData && 
         (userData.userID || userData.id) && 
         userData.nickname &&
         userData.avatar;
}

/**
 * 验证依赖数据完整性
 * @param {Object} dependencies - 依赖数据对象
 * @param {Array} requiredFields - 必需字段列表
 * @returns {boolean} - 是否完整
 */
function validateDependencies(dependencies, requiredFields) {
  return requiredFields.every(field => {
    const value = dependencies[field];
    return value !== null && value !== undefined && value !== '';
  });
}
```

##### 依赖状态跟踪
```javascript
// 页面级别的依赖状态管理
data() {
  return {
    dependencyStatus: {
      userDataLoaded: false,
      userDataValid: false,
      petDataLoaded: false,
      canLoadStats: false
    }
  }
},

methods: {
  updateDependencyStatus(key, value) {
    this.dependencyStatus[key] = value;
    this.checkCanProceed();
  },
  
  checkCanProceed() {
    // 检查是否可以执行下一阶段的请求
    this.dependencyStatus.canLoadStats = 
      this.dependencyStatus.userDataLoaded && 
      this.dependencyStatus.userDataValid;
  }
}
```

#### 错误处理与降级策略

##### 依赖失败处理
- **立即终止**：依赖数据获取失败时，立即终止所有后续请求
- **错误传播**：将依赖失败的原因传播给调用方
- **状态重置**：清理已加载的部分数据，避免不一致状态
- **用户提示**：向用户提供清晰的错误信息和重试选项

##### 降级方案
```javascript
async function loadDataWithFallback() {
  try {
    // 尝试加载完整数据
    const userData = await loadUserData();
    if (!userData) {
      // 降级到默认用户状态
      this.userInfo = getDefaultUserInfo();
      this.showLoginPrompt = true;
      return;
    }
    
    // 继续加载依赖数据
    await this.loadDependentData(userData);
    
  } catch (error) {
    console.error('数据加载失败:', error);
    // 降级到离线模式或缓存数据
    this.loadCachedData();
  }
}
```

#### 生命周期集成

##### 页面生命周期管理
```javascript
// 页面初始化时的依赖管理
onLoad() {
  this.initializeWithDependencies();
},

onShow() {
  // 根据依赖状态决定刷新策略
  if (!this.dependencyStatus.userDataValid) {
    this.initializeWithDependencies();
  } else {
    this.refreshNonDependentData();
  }
},

async initializeWithDependencies() {
  this.isInitializing = true;
  try {
    await this.loadDataWithDependencies();
  } finally {
    this.isInitializing = false;
  }
}
```

#### 调试与监控

##### 依赖关系日志
- **依赖检查日志**：记录每次依赖验证的结果
- **执行顺序日志**：记录请求的实际执行顺序
- **失败原因日志**：详细记录依赖失败的具体原因
- **性能监控日志**：记录依赖链的总执行时间

##### 开发工具支持
```javascript
// 开发环境下的依赖关系可视化
if (process.env.NODE_ENV === 'development') {
  console.group('[依赖管理] 数据加载流程');
  console.log('1. 基础依赖:', baseDependencies);
  console.log('2. 执行顺序:', executionOrder);
  console.log('3. 验证结果:', validationResults);
  console.groupEnd();
}
```

#### 最佳实践

##### 设计原则
1. **最小依赖原则**：尽量减少不必要的依赖关系
2. **快速失败原则**：依赖验证失败时立即返回，不浪费资源
3. **清晰边界原则**：明确定义每个数据的依赖边界
4. **可测试原则**：依赖关系应该易于单元测试

##### 代码组织
```javascript
// 推荐的依赖管理代码结构
class DataDependencyManager {
  constructor() {
    this.dependencies = new Map();
    this.loadingStatus = new Map();
  }
  
  async loadWithDependency(dataType, dependencies = []) {
    // 验证依赖
    for (const dep of dependencies) {
      if (!this.isLoaded(dep) || !this.isValid(dep)) {
        throw new Error(`依赖数据 ${dep} 未就绪`);
      }
    }
    
    // 执行加载
    return await this.load(dataType);
  }
}
```

### API请求处理规范

#### 统一请求处理
- 所有API请求必须通过统一封装的请求实例(例如Axios实例)进行发送
- 统一请求实例需负责处理：自动携带认证Token，请求和响应日志记录，统一的错误拦截与提示，以及请求加载状态(loading)管理

#### 请求重复预防机制
- 必需：true
- 实现：所有API请求必须实现防重复机制
- 策略：
  - 请求标识：为每个请求生成唯一标识符，由API路径+参数哈希+时间戳组成
  - 活跃请求跟踪：维护活跃请求Map，请求开始时添加，响应后移除
  - 重复检测：发送请求前检查是否有相同API路径和参数的请求正在进行
  - 等待机制：发现重复请求时，可选择等待首次请求完成或直接拒绝
  - 超时处理：设置最长等待时间，超时后自动清除标记并允许重新请求

#### API错误处理与回退策略
- 必需：true
- 错误类型区分：
  - 网络错误：请求未能发送或接收到服务器响应
  - 服务端错误：服务器返回5xx状态码
  - 客户端错误：服务器返回4xx状态码
  - 业务逻辑错误：服务器返回200但业务码非0
  - 超时错误：请求超过预设时间未收到响应
- 重试策略：
  - 网络错误和服务端错误可考虑重试，最多重试3次
  - 客户端错误和业务逻辑错误不应重试
  - 重试间隔应使用指数退避算法(300ms, 900ms, 2700ms)
  - 每次重试必须添加`_retry_count`参数标记重试次数
- 错误响应标准化：
  ```javascript
  {
    code: 非0数值,
    message: "人类可读的错误消息",
    errorType: "network_error|server_error|client_error|business_error|timeout",
    requestId: "请求唯一标识",
    details: { 具体错误详情 }
  }
  ```

#### API存在性验证
- 必需：true
- API注册表：
  - 维护全局API注册表，包含所有有效API路径模式
  - 格式：`{ path_pattern: { methods: ['GET', 'POST'], mockHandler: Function, requiresAuth: Boolean } }`
  - 在应用初始化时加载完整API注册表
- 请求验证：
  - 发送请求前检查API路径是否在注册表中
  - 未注册API直接返回标准错误响应，不发送实际请求
  - 错误响应：`{ code: 404, message: "API不存在", errorType: "api_not_found" }`
- 调试辅助：
  - 开发环境下，未找到API时提供可能的正确API路径建议
  - 记录所有API请求到日志，便于发现未注册API

### 前后端交互规范

#### 页面头部文档
- 必需：true
- 格式：
```
/*
* @page {页面名称}
* @description {页面功能描述}
* @author {作者}
* @date {创建日期}
* @update {更新日期}
*/
```
- 位置：每个页面文件顶部必须包含此注释块

#### API接口定义
- 必需：true
- 位置：每个页面组件内部顶部定义该页面需要的所有API接口
- 格式：
```javascript
// API接口定义
const API = {
  getData: '/api/module/getData',
  submitData: '/api/module/submitData'
};
```

#### 数据流文档
- 页面数据模式：在页面顶部注释中定义页面数据结构，包括输入和输出数据格式
- 状态管理：明确标注页面状态管理方式，如Vuex、Pinia或组件内状态
- 数据转换：记录数据转换逻辑，特别是API响应到UI展示的映射关系

#### 接口契约
- 定义位置：在src/api/模块名/index.js中定义所有接口
- TypeScript接口：使用TypeScript接口或JSDoc注释定义请求参数和响应数据类型
- 示例：
```javascript
/**
 * @typedef {Object} UserData
 * @property {string} id - 用户ID
 * @property {string} name - 用户名称
 */

/**
 * 获取用户数据
 * @param {Object} params - 请求参数
 * @param {string} params.userId - 用户ID
 * @returns {Promise<UserData>} - 用户数据
 */
export function getUserData(params) {
  return request.get('/api/user/getData', params);
}
```

#### 组件API依赖
- 声明：在组件选项或setup函数顶部声明组件依赖的所有API
- 格式：
```javascript
// 组件依赖的API
// getUserData - 获取用户数据
// updateUserProfile - 更新用户资料
```

#### 表单数据处理
- 验证规则：表单验证规则与后端验证保持一致，并在前端注释说明
- 数据转换：明确定义表单数据到API请求参数的转换逻辑
- 错误处理：定义表单提交错误的处理和展示方式

#### 页面到API映射
- 文档文件：维护一个pages-api-mapping.md文件，记录每个页面依赖的API接口
- 格式：
```markdown
| 页面路径 | 功能描述 | 依赖API | 请求方式 | 参数 | 响应 |
| --- | --- | --- | --- | --- | --- |
```

#### API状态跟踪
- 状态枚举：定义API开发状态枚举：PLANNED(计划中), MOCK_ONLY(仅Mock), DEVELOPING(开发中), COMPLETED(已完成)
- 跟踪文件：在api-status.json中跟踪所有API的开发状态
- 格式：
```json
{
  "api/user/getData": "COMPLETED",
  "api/user/updateProfile": "DEVELOPING"
}
```

### 数据分层设计思考规范

#### 核心思考原则
- **场景区分原则**：必须明确区分不同页面/组件的数据需求差异
- **显示模式分析**：分析组件支持的显示模式（如brief、mini、detailed），每种模式需要的字段不同
- **数据量级考虑**：首页列表需要简化数据，详情页需要完整数据
- **性能优先原则**：优先考虑网络传输效率和渲染性能

#### 必须思考的问题
1. **数据需求分析**：
   - 这个页面/组件实际需要展示哪些字段？
   - 不同显示模式下需要的字段有什么区别？
   - 哪些字段是首次加载必需的，哪些可以延迟加载？

2. **数据来源分析**：
   - 哪些数据可以通过ID实时获取？
   - 哪些数据需要预先计算或缓存？
   - 哪些数据会频繁变化，需要实时更新？

3. **关联数据处理**：
   - 关联数据是否应该在后端一次性组装？
   - 是否存在N+1查询问题？
   - 批量获取策略是否合理？

#### 数据分层设计检查清单
- [ ] 是否明确定义了每种显示模式的数据结构？
- [ ] 是否区分了列表页和详情页的数据需求？
- [ ] 是否考虑了大数据量场景下的性能问题？
- [ ] 是否设计了合理的数据填充控制机制？
- [ ] 是否避免了前端二次请求？

### 字段冗余分析规范

#### 冗余字段识别原则
- **ID可获取原则**：凡是可以通过ID实时获取的数据，都应该从Mock数据中移除
- **变化频率原则**：经常变化的数据（如昵称、头像、粉丝数）不应存储在关联表中
- **计算性数据原则**：可以实时计算的数据（如关注状态、统计数据）不应预存储
- **业务逻辑原则**：涉及业务逻辑的数据应该在后端实时处理

#### 必须分析的字段类型
1. **用户相关字段**：
   - 昵称、头像、简介 → 可删除，通过userID实时获取
   - 粉丝数、关注数 → 可删除，实时计算
   - 关注状态 → 可删除，基于currentUserId实时计算

2. **统计类字段**：
   - 评分、订单数、完成率 → 可删除，实时计算
   - 点赞数、评论数 → 可保留，但需要定期更新机制

3. **关联实体字段**：
   - 完整的宠物信息 → 可删除，保留宠物ID数组
   - 完整的商家信息 → 可删除，保留商家ID

#### 字段优化检查清单
- [ ] 是否识别了所有可通过ID获取的冗余字段？
- [ ] 是否保留了必要的关联ID字段？
- [ ] 是否区分了静态字段和动态字段？
- [ ] 是否设计了实时数据获取机制？
- [ ] 是否考虑了数据一致性问题？

### 分页性能优化思考规范

#### 大数据量场景考虑
- **数据量级评估**：必须考虑系统可能达到的数据量级（千级、万级、十万级）
- **分页策略选择**：根据数据特点选择合适的分页策略
- **索引设计**：考虑如何建立高效的数据索引
- **缓存策略**：设计合理的分页缓存机制

#### 分页策略思考
1. **ID范围分页**：
   - 适用场景：大数据量，数据相对稳定
   - 优势：性能最高，支持深度分页
   - 实现：使用startId和endId限定范围

2. **游标分页**：
   - 适用场景：实时数据，频繁更新
   - 优势：数据一致性好
   - 实现：使用lastId作为游标

3. **排除ID分页**：
   - 适用场景：下拉刷新，避免重复数据
   - 优势：用户体验好
   - 实现：使用excludeIds排除已加载数据

4. **传统分页**：
   - 适用场景：小数据量，简单场景
   - 优势：实现简单
   - 劣势：深度分页性能差

#### 分页性能检查清单
- [ ] 是否评估了系统可能的数据量级？
- [ ] 是否选择了合适的分页策略？
- [ ] 是否设计了索引和缓存机制？
- [ ] 是否考虑了分页的一致性问题？
- [ ] 是否测试了大数据量场景的性能？

### 控制条件设置规范

#### 参数控制设计原则
- **灵活性原则**：API参数应该支持多种使用场景
- **向后兼容原则**：新增参数不应影响现有功能
- **性能优化原则**：参数设计应该有利于性能优化
- **调试友好原则**：应该提供调试和监控参数

#### 必须设计的控制参数
1. **显示控制参数**：
   - displayMode：控制数据详细程度
   - includeUserDetails：是否包含用户详细信息
   - includeStats：是否包含统计信息

2. **分页控制参数**：
   - page、pageSize：传统分页参数
   - lastId：游标分页参数
   - startId、endId：范围分页参数
   - excludeIds：排除ID参数

3. **筛选控制参数**：
   - type：数据类型筛选
   - status：状态筛选
   - userId：用户筛选

4. **性能控制参数**：
   - useCache：是否使用缓存
   - timeout：请求超时时间
   - debug：调试模式开关

#### 控制条件检查清单
- [ ] 是否设计了完整的参数控制体系？
- [ ] 是否考虑了不同使用场景的参数需求？
- [ ] 是否提供了性能优化相关参数？
- [ ] 是否包含了调试和监控参数？
- [ ] 是否保证了参数的向后兼容性？

### 工具函数设计思考规范

#### 工具函数设计原则
- **单一职责原则**：每个工具函数只负责一个明确的功能
- **可复用原则**：工具函数应该在多个场景下可复用
- **性能优化原则**：工具函数应该考虑性能优化
- **错误处理原则**：工具函数应该有完善的错误处理

#### 必须考虑的工具函数类型
1. **数据获取工具**：
   - 批量获取用户信息
   - 批量获取实体数据
   - 实时计算统计数据

2. **数据处理工具**：
   - 数据格式转换
   - 数据验证和清洗
   - 数据关联和组装

3. **缓存管理工具**：
   - 缓存读写操作
   - 缓存失效管理
   - 缓存性能监控

4. **业务计算工具**：
   - 关注状态计算
   - 评分统计计算
   - 距离计算

#### 工具函数设计检查清单
- [ ] 是否识别了所有需要的工具函数？
- [ ] 是否遵循了单一职责原则？
- [ ] 是否考虑了批量处理优化？
- [ ] 是否设计了合理的错误处理？
- [ ] 是否提供了性能监控能力？

### 后端数据处理流程规范

#### 标准处理流程
1. **参数解析和验证**：
   - 解析所有请求参数
   - 验证参数有效性
   - 设置默认值

2. **数据源获取**：
   - 根据筛选条件获取基础数据
   - 应用业务规则筛选
   - 执行高效分页

3. **数据复制和隔离**：
   - 深复制数据避免污染
   - 仅处理当前页数据
   - 保护原始数据完整性

4. **实体数据填充**：
   - 批量获取关联数据
   - 实时计算动态数据
   - 组装完整数据结构

5. **业务规则应用**：
   - 应用权限控制
   - 计算用户交互状态
   - 执行业务逻辑

6. **响应数据组装**：
   - 构建标准响应格式
   - 添加分页信息
   - 包含调试信息

#### 处理流程检查清单
- [ ] 是否遵循了标准的处理流程？
- [ ] 是否在正确的步骤执行了分页？
- [ ] 是否避免了对全量数据的无效处理？
- [ ] 是否实现了完整的日志记录？
- [ ] 是否考虑了错误处理和降级？

## 五、Mock数据与测试规范

### 模拟数据规范

#### 数据结构
- Mock数据结构需与API返回结构完全一致，字段、类型、嵌套关系保持同步
- 有子数据时，仅存储子数据ID，不嵌入完整对象
- 每个实体类型单独维护Mock数据集，通过ID进行关联

#### ID引用
- ID统一用前缀+数字(如user_001)，保证唯一性和可读性
- 关联字段引用其他实体的ID，保持数据间一致性

#### 数据量
- 每类实体建议10-30条样本，覆盖常见状态和场景
- 时间字段用相对时间，状态字段覆盖主要业务流程

#### 接口一致性
- Mock接口路径、请求方式与真实API保持一致，支持常用参数(分页、过滤等)
- 按业务模块组织Mock数据文件，每个文件添加用途和字段说明注释

### Mock API处理

#### 社区模块处理顺序
1. 参数解析（如startId、endId、ids、lastId、pageSize等）
2. 按type等参数筛选数据源
3. ID分页（只保留ID符合条件的帖子）
4. 深复制（仅对本页数据深复制，防止污染原始数据）
5. 批量补全/修正（仅对本页数据做补全/修正）
6. 排序（如有需要，对本页数据排序）
7. 统一结构包装返回

#### 最佳实践
- ID分页必须在最前面，只处理本页数据，效率最高
- 数据补全/修正只针对本页数据，不会影响其它数据
- 如需排序，放在ID分页后，否则会影响分页准确性

#### 反模式
- 不要在ID分页前对全量数据做补全/修正，浪费性能
- 不要在分页后再对全量数据排序，否则分页结果会错乱

#### Mock处理特殊规范
- 必需：true
- 处理策略：
  - 每个Mock处理函数必须能处理所有合法的请求参数组合
  - 对无法识别的参数，应忽略而非报错
  - 确保函数内无不必要的循环、递归或大量计算
- 错误处理：
  - Mock处理函数内部错误不应抛出，而应返回标准错误响应
  - 使用try-catch包装所有Mock处理逻辑
  - 始终设置默认响应，确保即使处理失败也有合理返回
- 调试信息：
  - 记录详细的处理步骤日志
  - 跟踪错误来源并提供具体位置
  - 在响应中包含处理时间和处理函数标识

### 测试规范

#### 原则
- 遵循测试金字塔模型
- 测试代码需整洁、可维护
- 避免冗余测试逻辑
- 提高整体覆盖率

#### 类型
- 单元测试：验证独立逻辑单元
- 集成测试：验证模块协作逻辑
- 端到端测试：模拟完整用户流程
- 性能测试：关键路径性能评估

## 六、日志与监控规范

### API日志规范

#### 日志级别
- info：常规操作信息，如API调用开始、结束
- debug：调试信息，包含参数详情、中间处理结果等
- warning：警告信息，如参数不完整但可继续处理
- error：错误信息，如参数无效、处理失败等

#### 处理步骤日志
- 要求：每个处理步骤必须有明确的日志标记，格式为'[步骤X] 描述: 详情'
- 步骤标记：
  - 请求接收 - 记录接收到的原始请求数据
  - 参数解析 - 记录解析后的请求参数
  - 数据获取 - 记录从数据源获取的原始数据
  - 数据处理 - 记录数据处理过程和中间处理结果
  - 实体填充 - 记录实体数据填充过程
  - 响应构建 - 记录最终构建的响应数据

#### 性能日志
- 要求：true
- 时间点：
  - API处理开始时间
  - 数据源获取完成时间
  - 数据处理完成时间
  - 响应构建完成时间
  - API处理总耗时
- 格式：在日志中记录关键处理节点的时间戳和耗时，格式为'[计时] 步骤名称: XXms'

#### 数据量日志
- 要求：true
- 指标：
  - 请求参数数量和大小
  - 数据源记录数
  - 过滤后记录数
  - 填充的实体数量
  - 响应数据大小
- 格式：在日志中记录数据处理量，格式为'[数据量] 描述: 数量'

#### 条件日志
- 实现：根据请求参数中的debug标志或全局配置决定日志详细程度
- 级别：
  - 简要 - 仅记录主要处理步骤和结果
  - 标准 - 记录所有处理步骤和关键数据
  - 详细 - 记录所有处理步骤、中间数据和性能指标

#### 错误处理日志
- 要求：true
- 格式：错误日志必须包含错误类型、错误消息、错误位置和相关上下文数据
- 恢复动作：记录错误后的恢复操作或降级策略

### 处理流程日志

#### 基本要求
- 要求：true
- 实现位置：每个API处理函数必须实现详细的处理流程日志记录
- 日志格式：使用统一的日志格式，包含步骤编号、操作描述和关键数据

#### 日志结构
1. 开始标记: '--- 后端处理流程开始 ---'
2. 第1步: 接收请求，解析参数
3. 第2步: 获取当前用户上下文
4. 第3步: 数据源获取/查询
5. 第4步: 数据过滤/验证
6. 第5步: 实体数据填充
7. 第6步: 关联数据处理
8. 第7步: 业务规则应用
9. 第8步: 响应数据组装
10. 结束标记: '--- 后端处理流程结束 ---'

#### 实体填充日志
1. === 实体数据填充过程 ===
2. 步骤0: 配置填充选项
3. 步骤1: 创建数据副本
4. 步骤2-N: 各类实体数据填充
5. === 实体数据填充完成 ===

#### 统计与调试
- 数据统计：在日志结束前必须输出数据处理统计信息，如处理的记录数、过滤数、填充的实体数等
- 调试模式：提供debug参数用于控制日志输出级别，默认为简要日志，debug=true时输出详细日志
- 前端触发：在前端API调用函数中添加注释，说明此API在后端的处理流程日志可以通过控制台查看

## 七、数据优化与性能规范

### 实体数据提供者规范

#### 核心功能
- 单个和批量获取用户信息
- 用户关系状态计算（如是否关注）
- 宠物数据获取和关联
- 数据缓存管理

#### 标准接口
- getUserInfo(userId, options)：获取单个用户详细信息
- batchGetUsers(userIds, options)：批量获取用户基本信息
- batchGetEnhancedUsers(userIds, options)：批量获取增强版用户信息
- isUserFollowing(userId, targetId)：检查用户关注关系
- getUserFollowers(userId)：获取用户粉丝列表
- getUserFollowing(userId)：获取用户关注列表

#### 上下文参数
- 所有涉及用户关系的方法必须支持currentUserId参数
- 示例：getUserInfo(userId, { currentUserId, withPets: true })

#### 用户数据字段
标准用户数据应包含：
- 基本信息：userID、nickname、avatar、gender、bio
- 社交信息：followers(数量)、isFollowed(关注状态)
- 宠物信息：pets(宠物列表或数量)
- 标签信息：tags(用户标签，如"铲屎官"、"宠物医生")

### 数据流优化指南

#### 前端请求优化
- 使用前端存储（localStorage、sessionStorage）缓存不常变化的数据
- 实现内存缓存，避免短时间内重复请求相同数据
- 合理设置API响应的Cache-Control头，利用HTTP缓存

#### 错误处理与重试
- 实现请求失败后的智能重试策略
- 区分网络错误和业务逻辑错误
- 在UI上提供友好的错误提示

#### 优化重点场景
帖子详情页面优化原则：
1. 后端一次性返回完整数据，包括：
   - 发帖用户完整信息
   - 申请者完整信息（含评分、认证等）
   - 已接单申请者完整信息
   - 评论及回复完整信息
   - 其他相关业务数据

2. 前端避免对已完整数据进行二次请求：
   - 帖子详情页直接使用后端提供的完整数据
   - 相关页面间跳转时传递已有数据

## 八、文档与版本控制规范

### 文档要求

#### 项目文档
- 及时更新README和技术说明文档
- 所有文档使用中文编写
- 包含安装、使用、部署等说明
- 记录重要架构与设计决策

#### 国际化
- 注释、错误提示使用中文
- 预留国际化接口(如i18n)

### 版本控制

#### 基本配置
- 使用Git进行版本管理
- 配置合适的.gitignore
- 主分支受保护，限制直接提交

#### 分支管理
- 推荐采用Git Flow或Trunk Based模式
- 所有功能开发需在特性分支进行
- 定期清理无用分支

#### 提交规范
- 提交信息清晰明确
- 每次提交聚焦单一问题或功能
- 使用tag进行版本标记

#### 代码审查
- 所有合并需进行代码审查
- 遵循审查清单，确保代码一致性
- 审查结果需及时反馈与处理

## 九、开发环境与安全规范

### 开发环境

#### 依赖管理
- 使用对应语言的包管理工具(如npm、pip、composer等)
- 锁定依赖版本，确保构建可复现
- 定期更新依赖，修复安全问题
- 优先复用成熟工具，避免重复造轮子

### 安全规范
- 使用环境变量存储敏感配置
- 禁止在代码中硬编码密钥等敏感数据
- 定期扫描依赖库的安全风险
- 整合自动化工具进行漏洞检测

### 完成通知  
苏先生，我已经完成了您交代的所有任务 或 我本次请求已经调用工具超过15次，现在将执行：======================================================